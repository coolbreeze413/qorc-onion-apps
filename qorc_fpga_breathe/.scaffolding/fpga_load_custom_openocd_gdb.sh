#!/bin/bash


# load the fpga design (.openocd) with BEFORE and AFTER steps as needed, using gdb to comm with the openocd server
# REQ:
# 1. OpenOCD probe is connected to EOS_S3 and it is in DEBUG mode
# 2. openocd is available in the path ('source debugenvsetup.sh')
# 3. (.openocd) has been generated by adding a 'openocd' to the -dump command to ql_symbiflow


OPENOCD_PATH=$(which openocd)
OPENOCD_INTERACE_CFG="interface/jlink_swd.cfg"
GDB_PATH=$(which arm-none-eabi-gdb)
################################################################################
#   getopt based parsing
################################################################################
# option strings
SHORT="" # no short options at all, clearer that way.
# reference on how to enforce no short options: https://unix.stackexchange.com/questions/162624/how-to-use-getopt-in-bash-command-line-with-only-long-options
LONG="openocd-path:,openocd-if-cfg:,gdb-path:,help"


# read the options
OPTS=$(getopt --options "$SHORT" --long "$LONG" --name "$0" -- "$@")

if [ $? != 0 ] ; then echo "ERROR: failed to parse options...exiting." >&2 ; exit 1 ; fi

eval set -- "$OPTS"

usage()
{
    printf "\n"
    printf "[%s] usage:\n" $(basename $0)
    printf "\n"
    printf "build the fpga design\n"
    printf "\n"
    printf " syntax: $0 --openocd-path=/path/to/openocd --openocd-if-cfg=/path/to/probe/cfg --gdb-path=/path/to/arm-none-eabi-gdb\n"
    printf "\n"
    printf "example: $0 --openocd-path=/usr/bin/openocd --openocd-if-cfg=interface/ft2232h_swd.cfg --gdb-path=/usr/bin/arm-none-eabi-gdb\n"
    printf "\n"
}

# extract options and their arguments into variables
while true ; do
    case "$1" in
        --openocd-path )
            OPENOCD_PATH="$2"
            shift 2
        ;;
        --openocd-if-cfg )
            OPENOCD_INTERACE_CFG="$2"
            shift 2
        ;;
        --gdb-path )
            GDB_PATH="$2"
            shift 2
        ;;
        -- )
            shift
            break
        ;;
        -h | --help | *)
            usage
            exit 0
        ;;
    esac
done

# arg checks
if [ -z "$OPENOCD_PATH" ] ; then
    printf "\nERROR: OPENOCD_PATH is not defined!\n"
    usage
    exit 1
fi

if [ -z "$OPENOCD_INTERACE_CFG" ] ; then
    printf "\nERROR: OPENOCD_INTERACE_CFG is not defined!\n"
    usage
    exit 1
fi

if [ -z "$GDB_PATH" ] ; then
    printf "\nERROR: GDB_PATH is not defined!\n"
    usage
    exit 1
fi


# confirmation print
printf "\n"
printf "OPENOCD_PATH=$JLINK_EXE_PATH\n"
printf "OPENOCD_INTERACE_CFG=$OPENOCD_INTERACE_CFG\n"
printf "GDB_PATH=$GDB_PATH\n"
printf "\n"
################################################################################



PROJECT_ROOT_DIR=$(cd .. ; printf %s "$PWD")
PROJECT_RTL_DIR="${PROJECT_ROOT_DIR}/fpga/rtl"


# the generated .openocd script only focusses on loading the design and setting the IOMUX
#  registers for the design - it does not do anything related to initialization of the EOS_S3
# typically, we need to ensure that the EOS_S3 has been reset before loading the design.


OPENOCD_FPGA_DESIGN_SCRIPT=$(ls "$PROJECT_RTL_DIR"/*.openocd)
#echo "$OPENOCD_FPGA_DESIGN_SCRIPT"

CUSTOM_OPENOCD_GDB_LOG="fpga_load_custom_openocd_gdb.log"

# run openocd (background, suppress output)
"$OPENOCD_PATH" -f "$OPENOCD_INTERACE_CFG" -f target/eos_s3.cfg -f "${OPENOCD_FPGA_DESIGN_SCRIPT}" > "$CUSTOM_OPENOCD_GDB_LOG" 2>&1 &

# wait a second for the openocd server to startup
sleep 1

# ref: https://stackoverflow.com/a/58137098
# ref: https://stackoverflow.com/a/46867839
# run gdb, do stuff, and shutdown (both gdb and openocd get terminated gracefully)
"$GDB_PATH" -batch -ex "target extended-remote localhost:3333" \
                   -ex "monitor init" \
                   -ex "monitor reset halt" \
                   -ex "monitor load_bitstream" \
                   -ex "monitor mdw 0x40005484" \
                   -ex "monitor shutdown"

# remove the custom script/log (disable for debugging the script)
rm "$CUSTOM_OPENOCD_GDB_LOG"
