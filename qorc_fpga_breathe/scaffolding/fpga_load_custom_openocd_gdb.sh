#!/bin/bash


# load the fpga design (.openocd) with BEFORE and AFTER steps as needed, using gdb to comm with the openocd server
# REQ:
# 1. OpenOCD probe is connected to EOS_S3 and it is in DEBUG mode
# 2. openocd is available in the path ('source debugenvsetup.sh')
# 3. (.openocd) has been generated by adding a 'openocd' to the -dump command to ql_symbiflow

PROJECT_ROOT_DIR=$(cd .. ; printf %s "$PWD")
PROJECT_RTL_DIR="${PROJECT_ROOT_DIR}/fpga/rtl"

# fallback to assuming it is on the path
OPENOCDEXE="openocd"
GDBEXE="arm-none-eabi-gdb"

# if arguments is passed to this script, then it must to path to openocd + gdb
# $1 == path to openocd
# $2 == path to gdb
if [ $# == 2 ] ; then
    OPENOCDEXE="$1"
    GDBEXE="$2"
fi

# the generated .openocd script only focusses on loading the design and setting the IOMUX
#  registers for the design - it does not do anything related to initialization of the EOS_S3
# typically, we need to ensure that the EOS_S3 has been reset before loading the design.


OPENOCD_FPGA_DESIGN_SCRIPT=$(ls "$PROJECT_RTL_DIR"/*.openocd)
#echo "$OPENOCD_FPGA_DESIGN_SCRIPT"

CUSTOM_OPENOCD_GDB_LOG="fpga_load_custom_openocd_gdb.log"

# run openocd (background, suppress output)
"$OPENOCDEXE" -f interface/jlink_swd.cfg -f target/eos_s3.cfg -f "${OPENOCD_FPGA_DESIGN_SCRIPT}" > "$CUSTOM_OPENOCD_GDB_LOG" 2>&1 &

# wait a second for the openocd server to startup
sleep 1

# ref: https://stackoverflow.com/a/58137098
# ref: https://stackoverflow.com/a/46867839
# run gdb, do stuff, and shutdown (both gdb and openocd get terminated gracefully)
"$GDBEXE" -batch -ex "target extended-remote localhost:3333" -ex "monitor init" -ex "monitor reset halt" -ex "monitor load_bitstream" -ex "monitor mdw 0x40005484" -ex "monitor shutdown"

# remove the custom script/log (disable for debugging the script)
rm "$CUSTOM_OPENOCD_GDB_LOG"
